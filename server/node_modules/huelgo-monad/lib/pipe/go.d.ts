interface GoReturnParmas<E, T> {
    isOk: Boolean;
    value?: T;
    error?: E;
}
/**
 * @desc 앞으로 당당히 걸어가자
 * @param {initParam} initParam 초기값
 * @param {...fns} ...fns 조건 함수 들
 */
export declare const go: <T>(initParam: T, ...fns: any[]) => T;
/**
 * @desc 힘들지만 앞으로 당당히 걸어가자
 * @param {initParams} initParams 초기값
 * @param {...fns} ...fns 조건 함수 들
 */
export declare const asyncGo: <T>(initParams: T, ...promiseFns: any[]) => Promise<GoReturnParmas<string, T>>;
/**
 * @desc 복잡하지만 앞으로 당당히 걸어가자
 * @param {initParams} initParams 초기값
 * @param {...fns} ...fns 조건 함수 들
 */
export declare const mixedGo: <T>(initParams: T, ...funcs: any[]) => Promise<GoReturnParmas<string, T>>;
interface ConditionParmas<E, T> {
    func: (num: T) => boolean | Promise<boolean>;
    error: E;
}
/**
 * @desc 조건을 이겨내보자
 * @param {initParam} initParam 초깃값
 * @param {isCondition} isCondition 조건값
 * @param {conditions} conditions 조건함수들
 */
export declare function conditionGo<E, T>(initParam: T, isCondition: boolean, ...conditions: ConditionParmas<E, T>[]): GoReturnParmas<E, T>;
/**
 * @desc 힘든조건도 이겨내보자
 * @param {initParams} initParams 초깃값
 * @param {isCondition} isCondition 조건값
 * @param {condition} condition 조건함수들
 */
export declare function conditionMixedGo<E, T>(initParams: T, isCondition: boolean, ...condition: ConditionParmas<E, T>[]): Promise<GoReturnParmas<E, T>>;
export {};
