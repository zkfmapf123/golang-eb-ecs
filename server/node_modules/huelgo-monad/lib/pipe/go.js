"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.conditionMixedGo = exports.conditionGo = exports.mixedGo = exports.asyncGo = exports.go = void 0;
const isPromise = (fn) => { var _a; return ((_a = fn === null || fn === void 0 ? void 0 : fn.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'AsyncFunction'; };
/////////////////////////////////////////////////// go, asyncGo, mixedGo ////////////////////////////////////////
/**
 * @desc 앞으로 당당히 걸어가자
 * @param {initParam} initParam 초기값
 * @param {...fns} ...fns 조건 함수 들
 */
const go = (initParam, ...fns) => {
    for (const fn of fns)
        initParam = fn(initParam);
    return initParam;
};
exports.go = go;
/**
 * @desc 힘들지만 앞으로 당당히 걸어가자
 * @param {initParams} initParams 초기값
 * @param {...fns} ...fns 조건 함수 들
 */
const asyncGo = (initParams, ...promiseFns) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        for (const promiseFn of promiseFns)
            initParams = yield promiseFn(initParams);
        return {
            isOk: true,
            value: initParams,
        };
    }
    catch (e) {
        return {
            isOk: false,
            value: e,
        };
    }
});
exports.asyncGo = asyncGo;
/**
 * @desc 복잡하지만 앞으로 당당히 걸어가자
 * @param {initParams} initParams 초기값
 * @param {...fns} ...fns 조건 함수 들
 */
const mixedGo = (initParams, ...funcs) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        for (const func of funcs) {
            if (isPromise(func)) {
                initParams = yield func(initParams);
                continue;
            }
            initParams = func(initParams);
        }
        return {
            isOk: true,
            value: initParams,
        };
    }
    catch (e) {
        return {
            isOk: false,
            value: e,
        };
    }
});
exports.mixedGo = mixedGo;
/**
 * @desc 조건을 이겨내보자
 * @param {initParam} initParam 초깃값
 * @param {isCondition} isCondition 조건값
 * @param {conditions} conditions 조건함수들
 */
function conditionGo(initParam, isCondition, ...conditions) {
    for (const { func, error } of conditions) {
        if (isCondition !== func(initParam)) {
            return {
                isOk: false,
                error,
            };
        }
    }
    return {
        isOk: true,
    };
}
exports.conditionGo = conditionGo;
/**
 * @desc 힘든조건도 이겨내보자
 * @param {initParams} initParams 초깃값
 * @param {isCondition} isCondition 조건값
 * @param {condition} condition 조건함수들
 */
function conditionMixedGo(initParams, isCondition, ...condition) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            for (const { func, error } of condition) {
                // promise
                if (isPromise(func)) {
                    if (isCondition !== (yield func(initParams))) {
                        return {
                            isOk: false,
                            error,
                        };
                    }
                }
                if (isCondition !== func(initParams)) {
                    return {
                        isOk: false,
                        error,
                    };
                }
            }
            return {
                isOk: true,
            };
        }
        catch (e) {
            return {
                isOk: false,
                error: e,
            };
        }
    });
}
exports.conditionMixedGo = conditionMixedGo;
//# sourceMappingURL=go.js.map